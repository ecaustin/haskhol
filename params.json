{"name":"HaskHOL","tagline":"The Main HaskHOL project page","body":"# News\r\n01/01/2015 - Began transitioning HaskHOL's project page to GitHub to prepare for my departure/graduation from KU.\r\n\r\n\r\n# Description\r\n\r\nHaskHOL is a Haskell hosted domain specific language for Higher-Order Logic (HOL) theorem proving.\r\nThe goal of HaskHOL is to provide a lightweight, general purpose theorem proving library for direct use by other Haskell programs and libraries.\r\n\r\nHaskHOL, like every other member of the HOL proof system family, follows the LCF implementation style -- it starts with a sound and simple logical kernel from which more advanced features are bootstrapped.\r\nThe primitive logic of HaskHOL is inspired heavily by Freek Wiedijk's [Stateless HOL](http://www.cs.ru.nl/~freek/notes/hol_light-stateless.tar.gz) and Norbert Voelker's [HOL2P](http://dces.essex.ac.uk/staff/norbert/hol2p/); both of which are extensions of John Harrison's [HOL Light](http://www.cl.cam.ac.uk/~jrh13/hol-light/).\r\n\r\nAt the lowest level, HaskHOL's logical kernel is a \"psuedo-stateless\" implementation of a HOL logic that supports limited second-order polymorphism.  This logic is essentially a confluence of Wiedijk and Voelker's logics, with a subtle modification to the stateless approach to embed hashes for comparison, rather than definitional values.  This allows HaskHOL to efficiently represent and operate over its primitive data types, even in the presence of non-lazy traversals.  As a brief aside, the current reliance on hashes is potentially unsound, however, that should be fixed by moving to static keys as provided by the static pointers implementation coming soon to GHC.\r\n\r\nThe stateful features of the HaskHOL system are built on top of this kernel by simulating the desired side effects via a computational monad.  We find this segregation to be beneficial, as the implementation of the side effects does not need to worry about maintaining the soundness of the system, provided that the interface exposed by the kernel is respected.\r\nThe [haskhol-core](https://github.com/ecaustin/haskhol-core) package provides the kernel, stateful layer, and other basic functionality (parser, pretty-printer, etc.) of HaskHOL.\r\nAdditional packages providing more advanced libraries are in an experimental, semi-stable state, but should be made publicly available soon.\r\n\r\nThe current focus of the HaskHOL project is developing a linkage with GHC at the compiler plugin level for the purpose of verifying Haskell code natively at compile time.\r\n\r\n\r\n# Status\r\n\r\nThe Core HaskHOL system is now publicly available on Hackage.\r\nProvided you have an up to date Haskell and Cabal installation, installing HaskHOL-Core should be as easy as running the command: `cabal install haskhol-core`\r\n\r\nAdditional libraries are available by request.\r\nThey will be released publicly, pending a code review and documentation.\r\n\r\nA basic tutorial is in the works, but its availability is currently unknown.\r\nIn the mean time, we encourage you to consult the documentation of the previously mentioned systems, and Gordon and Melham's *Introduction to HOL*, to answer any HOL questions you may have.\r\n\r\n\r\n# Papers\r\n\r\n* Austin, E., and P. Alexander, [HaskHOL: A Haskell Hosted Domain Specific Language Representation of HOL Light](/haskhol/papers/haskhol-tfp10.pdf), Trends in Functional Programming (TFPâ€™10), Norman, OK, May 17-19, 2010.\r\n    \r\n    This draft publication details the very earliest implementation of HaskHOL -- a naive translation of HOL Light's logical kernel into a functionally-equivalent Haskell version.  The crux of the work was identifying both the requisite OCaml side-effects and a monad transformer stack that could simulate them.  This version failed miserably for a number of reasons, but it framed the basic design of HaskHOL that's still used today.  There's also a brief mention of using QuickCheck to verify the prover kernel by testing with generators for well-formed proof terms, but that work has sadly gone neglected in the last few years.\r\n\r\n\r\n* Austin, E., and P. Alexander, [Haskell + HOL = HaskHOL](/haskhol/papers/haskhol-ifl11.pdf), 2011 Symposium on Implementation and Application of Functional Langauges (IFL'11), Lawrence, KS, 2011.\r\n\r\n    This draft publication details the first revision of the implementation of HaskHOL.  The major changes included:\r\n    * A mechanism for extensible state to support libraries introducing new fields to the working theory.\r\n    * A move to a monad stack based on `IO`.\r\n    * A foundation for implementing HaskHOL libraries that modified the current working theory.\r\n    \r\n    This paper is also noteworthy for including the first performance metrics for HaskHOL.  Summarized:  HaskHOL worked, but it was incredibly slow.  There were known space leak issues and most non-trivial proofs expanded out to computations where sub-proofs were used, and thus recomputed, repeatedly.  Still.  It worked, which was pretty exciting at the time.\r\n\r\n\r\n* Austin, E., and P. Alexander, [Haskell + HOL = HaskHOL](/haskhol/papers/haskell+hol=haskhol-updated.pdf), Unpublished, 2012.\r\n\r\n    This unpublished paper is an updated draft of the previous publication.  The glaring issues with HaskHOL at the time, namely the space leaks, were fixed and the performance evaluation was rerun; this time with an apples-to-oranges comparison with HOL Light.  In short, flattening the monad stack, switching to a more time efficient data structure for extensible state, and making some basic algorithmic adjustments guided by profiling lead to a pretty extreme increase in performance.\r\n\r\n    This paper was also the first time that I touched upon the potential soundness (incorrectly referred to as safety in this draft) issues that come with using the MTL.\r\n\r\n\r\n\r\n\r\n\r\nThe best description of the primitive logic behind HaskHOL is contained within our submission to ITP2013, Stateless Higher-Order Logic with Quantified Types: [HaskHOL ITP 2013](http://people.eecs.ku.edu/~eaustin/papers/haskhol_itp2013.pdf)","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}